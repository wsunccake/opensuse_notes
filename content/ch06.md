# ch6. BASH Shell 腳本編程

BASH (Bourne-Again SHell) 是現今 Linux 發行版中最常見的預設 Shell。它不僅是使用者與核心溝通的介面，更是一種強大的腳本語言。本章將介紹 Shell 的基本概念、BASH 的設定與語法，以及多種實用的文本處理指令。

## 6-1. Shell 簡介

Shell 是一個命令列直譯器，它接收使用者的指令，呼叫對應的核心功能來完成任務。除了 BASH，還有許多其他種類的 Shell，各自有其特色。

- **`sh (Bourne Shell)`**: 由 Stephen Bourne 在貝爾實驗室開發，是 UNIX 系統上第一個廣泛使用的 Shell。它的語法奠定了今日 BASH 的基礎，許多舊系統或嵌入式設備仍會使用它或其相容版本。
- **`bash (Bourne-Again SHell)`**: 作為 `sh` 的超集合，`bash` 提供了更多功能，如命令歷史、Tab 自動補全、更豐富的腳本語法等。它是 GNU 計畫的一部分，也是 openSUSE 和多數 Linux 發行版的預設 Shell。
- **`csh (C Shell)`**: 由 Bill Joy 在加州大學柏克萊分校開發，語法類似 C 語言，引入了命令別名 (alias) 和工作控制 (job control) 等功能，深受部分程式設計師喜愛。
- **`tcsh (TENEX C Shell)`**: `csh` 的增強版本，加入了命令列編輯和自動補全等功能，使其更易於使用。
- **`ksh (Korn Shell)`**: 由 David Korn 在貝爾實驗室開發，試圖結合 `sh` 的語法和 `csh` 的便利功能。它在商業 UNIX 系統中相當流行，具備高效能和強大的陣列與算術運算功能。
- **`ash (A Shell)`**: 一個輕量級的 Shell，功能比 `sh` 少，主要用於資源有限的環境，例如嵌入式系統。
- **`dash (Debian Almquist Shell)`**: `ash` 的一個分支，在 Debian 和 Ubuntu 中，`/bin/sh` 預設連結到 `dash`。它的執行速度比 `bash` 快，主要用於執行系統啟動腳本，以提升開機效率。
- **`zsh (Z Shell)`**: 一個功能極其強大的 Shell，結合了 `bash`, `ksh`, `tcsh` 的許多優點。它提供更進階的自動補全、拼寫校正、主題化提示字元等，搭配 "Oh My Zsh" 等框架後，可以打造出高度客製化的工作環境。
- **`fish (Friendly Interactive SHell)`**: 強調開箱即用的使用者體驗。它預設提供了語法高亮、智慧自動建議等功能，不需要複雜設定就能擁有現代化的操作介面，但其腳本語法與 `sh`/`bash` 不完全相容。

### 6-1-1. BASH 設定檔

BASH 的行為可以透過多個設定檔進行客製化。了解它們的載入順序對於環境變數、別名和函式的設定至關重要。

- **Login Shell**: 使用者登入系統時取得的 Shell (例如，在 TTY 終端機輸入帳號密碼，或透過 SSH 遠端連線)。
- **Non-Login Shell**: 在已登入的環境中開啟的 Shell (例如，在圖形介面中開啟終端機視窗)。

**載入順序 (Login Shell):**

1.  **/etc/profile**: 系統全域設定檔。所有使用者的 Login Shell 都會先執行這個檔案，通常用於設定 `PATH` 等全域環境變數。
2.  **~/.bash_profile, ~/.bash_login, ~/.profile**: 使用者個人設定檔。BASH 會依序尋找這三個檔案，且只會執行找到的第一個。`~/.profile` 是最通用的，因為 `sh` 和 `ksh` 也會讀取它。openSUSE 預設使用 `~/.profile`。

下面是 Login Shell 載入設定檔的流程圖：

```text
+----------------------+
|      login           |
+----------------------+
          |
          v
+----------------------+
|  read /etc/profile   |
+----------------------+
          |
          v
+--------------------------+
| find ~/.bash_profile ?   |-- (Y) -->+------------------------+
+--------------------------+          | read ~/.bash_profile   |
          | (N)                       +------------------------+
          v                                      |
+--------------------------+                     |
| find ~/.bash_login ?     |-- (Y) -->+----------------------+
+--------------------------+          | read ~/.bash_login   |
          | (N)                       +----------------------+
          v                                      |
+--------------------------+                     |
| find ~/.profile ?        |-- (Y) -->+--------------------+
+--------------------------+          | read ~/.profile    |
          | (N)                       +--------------------+
          v                                      |
+----------------------+                         |
|      done            |<------------------------+
+----------------------+
```

> **提示**: 一個常見的最佳實踐是在 `~/.bash_profile` 或 `~/.profile` 中加入程式碼來主動載入 `~/.bashrc`，這樣無論是 Login 還是 Non-Login Shell 都能共享相同的別名與函式設定。
>
> ```bash
> # in ~/.bash_profile
> if [ -f ~/.bashrc ]; then
>   . ~/.bashrc
> fi
> ```

**載入順序 (Non-Login Shell):**

1.  **/etc/bash.bashrc**: 系統全域設定檔，適用於 Non-Login Shell。
2.  **~/.bashrc**: 使用者個人設定檔。當開啟新的終端機視窗時，主要會讀取此檔案來設定別名、提示字元等。通常 `~/.profile` 會在其內容中明確呼叫 `~/.bashrc`，以確保兩種模式的設定一致。

### 6-1-2. 環境設定指令

- **`alias`**: 設定指令的別名。

  - **設定別名**:
    ```bash
    # 讓 'll' 指令等同於 'ls -l --color=auto'
    tux@suse16:~> alias ll='ls -l --color=auto'
    ```
  - **取消別名**:
    ```bash
    tux@suse16:~> unalias ll
    ```

- **`set`**: 顯示或設定 Shell 的所有變數，包含環境變數和使用者自訂變數。
- **`env`**: 顯示當前 Shell 的環境變數。這些變數會被子程序繼承。
- **`export`**: 將一個自訂變數提升為環境變數，使其能被子程序存取。
  - **設定與導出**:
    ```bash
    # 宣告一個自訂變數
    tux@suse16:~> MY_VAR="suse"
    # 將它轉為環境變數
    tux@suse16:~> export MY_VAR
    # 或者直接宣告並導出
    tux@suse16:~> export ANOTHER_VAR="linux"
    ```

### 6-1-3. Script

腳本 (Script) 是一個包含多個指令的純文字檔案，可以被循序執行。

- **Shebang (`#!`)**: 腳本的第一行通常是 `#!/bin/bash`，稱為 "Shebang"。它告訴系統要使用哪個直譯器來執行此檔案。

- **範例 `hello.sh`**:

  ```bash
  #!/bin/bash
  # 這是一個註解，說明腳本的用途
  # hello.sh: 一個簡單的 "Hello, world!" 腳本

  echo "Hello, world!"
  ```

- **執行腳本**:
  - **方法一：使用 `bash` 指令執行** (不需要執行權限)
    ```bash
    tux@suse16:~> bash hello.sh
    Hello, world!
    ```
  - **方法二：賦予執行權限後直接執行**
    ```bash
    # 使用 chmod +x 增加執行權限
    tux@suse16:~> chmod +x hello.sh
    # 執行 (./ 代表當前目錄)
    tux@suse16:~> ./hello.sh
    Hello, world!
    ```

#### 練習

1.  建立一個別名 `mydocs`，讓它能快速切換到 `~/Documents` 目錄。
2.  在 `~/.bashrc` 中加入一個自訂的環境變數 `EDITOR` 並設為 `vim`，然後重新開啟一個終端機，使用 `env | grep EDITOR` 檢查是否生效。
3.  撰寫一支名為 `sysinfo.sh` 的腳本，執行後能顯示目前的日期 (`date`)、登入的使用者 (`whoami`) 以及核心版本 (`uname -r`)。

---

## 6-2. BASH 基礎語法

### 6-2-1. 變數 (Variable)

變數是用於儲存資料的容器。BASH 中的變數不需要事先宣告型別。

- **命名規則**:

  - 只能包含英文字母、數字和底線 (`_`)。
  - 不能以數字開頭。
  - 變數名稱大小寫敏感 (`VAR` 和 `var` 是不同變數)。
  - 習慣上，環境變數使用全大寫，自訂變數使用小寫或駝峰式。

- **純量變數 (Scalar Variable)**:

  ```bash
  # 賦值 (等號兩邊不能有空格)
  name="openSUSE"
  version=16
  # 取用 (在變數名前加上 $)
  echo "Welcome to $name $version"
  # 使用大括號以區分變數範圍
  echo "This is ${name}Leap"
  ```

- **陣列 (Array)**:

  ```bash
  # 宣告陣列
  distros=("openSUSE" "Fedora" "Ubuntu" "Arch")
  # 取用陣列元素 (索引從 0 開始)
  echo "First distro: ${distros[0]}"
  # 取用所有元素
  echo "All distros: ${distros[@]}"
  ```

- **關聯陣列 (Associative Array)**: 類似其他語言的字典或 Map，使用字串作為索引。
  ```bash
  # 宣告關聯陣列
  declare -A user_info
  # 賦值
  user_info["name"]="Tux"
  user_info["os"]="Linux"
  # 取用
  echo "${user_info[name]} is using ${user_info[os]}"
  ```

### 6-2-2. 條件與迴圈

- **`if` 條件判斷**:

  ```bash
  #!/bin/bash
  count=10
  if [ $count -eq 10 ]; then
    echo "Count is 10."
  fi

  # if/else
  if [ "$USER" == "root" ]; then
    echo "You are the administrator."
  else
    echo "You are a regular user."
  fi
  ```

  - **常用判斷式**:
    - `-eq` (等於), `-ne` (不等於), `-gt` (大於), `-lt` (小於)
    - `-f` (檔案存在), `-d` (目錄存在), `-z` (字串為空)

- **`case` 多重條件**:

  ```bash
  #!/bin/bash
  read -p "Enter a fruit: " fruit
  case $fruit in
    "apple")
      echo "It's a red fruit."
      ;;
    "banana")
      echo "It's a yellow fruit."
      ;;
    *)
      echo "Unknown fruit."
      ;;
  esac
  ```

- **`for` 迴圈**:

  ```bash
  # 遍歷清單
  for i in 1 2 3 4 5; do
    echo "Number: $i"
  done

  # C-style for loop
  for (( c=1; c<=5; c++ )); do
    echo "Count: $c"
  done
  ```

- **`while` 迴圈**:
  ```bash
  counter=1
  while [ $counter -le 5 ]; do
    echo "Counter: $counter"
    ((counter++))
  done
  ```

- **`until` 迴圈**: `until` 與 `while` 相反，它會持續執行迴圈，直到條件變成「真」。
  ```bash
  # 持續執行直到 counter 大於 5
  counter=1
  until [ $counter -gt 5 ]; do
    echo "Until Counter: $counter"
    ((counter++))
  done
  ```

- **`select` 選單迴圈**: `select` 可以輕鬆地建立一個互動式選單。
  ```bash
  #!/bin/bash
  PS3="Please choose your distro: " # 設定 select 的提示字元
  distros=("openSUSE" "Fedora" "Ubuntu" "Quit")
  select fav in "${distros[@]}"; do
    case $fav in
      "openSUSE")
        echo "Geeko is the best!"
        ;;
      "Fedora" | "Ubuntu")
        echo "$fav is a great choice too."
        ;;
      "Quit")
        echo "Bye!"
        break # 跳出 select 迴圈
        ;;
      *)
        echo "Invalid option $REPLY"
        ;;
    esac
  done
  ```

### 6-2-3. 函式 (Function)

函式可以將一組指令包裝起來，方便重複使用。

- **定義與呼叫**:

  ```bash
  #!/bin/bash
  # 定義函式
  function greet() {
    echo "Hello, $1"
  }

  # 呼叫函式並傳遞參數
  greet "Tux"
  greet "Geeko"
  ```

- **回傳值與參數**:

  - BASH 函式的 `return` 只能回傳 0-255 的整數，通常用於表示函式的執行狀態 (0 代表成功，非 0 代表失敗)。
  - 若要回傳字串或複雜資料，通常是透過 `echo` 將結果輸出，然後由呼叫者使用命令替換 `$(...)` 來接收。

  ```bash
  function get_date() {
    # 將日期字串輸出到 stdout
    date
  }

  current_date=$(get_date)
  echo "Today is: $current_date"
  ```

- **變數範圍 (Variable Scope) 與 `local`**:
  預設情況下，BASH 腳本中的變數都是全域 (global) 的，即使在函式中宣告也一樣。這意味著函式內部的變數修改會影響到函式外部。為了避免這種副作用，應該使用 `local` 關鍵字來宣告函式內部的區域變數。

  - **`local`**: 宣告一個或多個變數，其可見範圍僅限於當前的函式及其子程序。

  - **範例**:
    ```bash
    #!/bin/bash
    my_var="global" # 這是一個全域變數

    function my_func() {
      # 使用 local 宣告一個同名的區域變數
      local my_var="local"
      echo "Inside function: my_var is $my_var"
    }

    echo "Before function call: my_var is $my_var"
    my_func
    echo "After function call: my_var is $my_var"
    ```
  - **執行結果**:
    ```text
    Before function call: my_var is global
    Inside function: my_var is local
    After function call: my_var is global
    ```
    如結果所示，函式內對 `local` 變數的修改不會影響到外部的同名全域變數，這是良好腳本設計的關鍵。

#### 練習

1.  寫一個腳本，宣告一個陣列包含三種程式語言，然後用 `for` 迴圈將它們一一印出。
2.  寫一個腳本，接收一個參數 (檔名)，然後判斷該檔案是否存在。如果存在，顯示 "File exists"；否則顯示 "File not found"。
3.  建立一個名為 `backup` 的函式，它接收一個檔名作為參數，並將該檔案複製到 `/tmp` 目錄下。
4.  寫一個腳本，使用 `until` 迴圈，每秒檢查一次 `/tmp/stop.flag` 檔案是否存在。如果檔案存在，腳本就印出 "Stop signal received." 並結束。
5.  使用 `select` 建立一個腳本，提供 `Show Date`, `Show Uptime`, `Exit` 三個選項。使用者選擇後，執行對應的指令 (`date`, `uptime`) 或退出腳本。

---

## 6-3. 進階概念

### 6-3-1. 標準輸入、標準輸出與標準錯誤

在 Linux 中，每個程序預設都會開啟三個檔案描述符 (File Descriptor):

- **`stdin` (0)**: 標準輸入，預設來自鍵盤。
- **`stdout` (1)**: 標準輸出，預設顯示在螢幕。
- **`stderr` (2)**: 標準錯誤，預設也顯示在螢幕。

**重新導向 (Redirection)**:

- `>`: 將 `stdout` 導向到檔案 (覆蓋)。
- `>>`: 將 `stdout` 導向到檔案 (附加)。
- `2>`: 將 `stderr` 導向到檔案。
- `&>`: 將 `stdout` 和 `stderr` 同時導向到檔案。
- `<`: 將檔案內容作為 `stdin`。

- **範例**:

  ```bash
  # 將 ls 的結果寫入 file.list (stdout)
  tux@suse16:~> ls -l > file.list

  # 執行一個不存在的指令，將錯誤訊息寫入 error.log (stderr)
  tux@suse16:~> non_exist_cmd 2> error.log

  # 將所有輸出 (stdout & stderr) 都導向到 /dev/null (黑洞，即丟棄)
  tux@suse16:~> some_command &> /dev/null
  ```

### 6-3-2. 管線 (Pipeline)

管線 (`|`) 是 Shell 中一個極其強大的功能，它可以將一個指令的 `stdout` 作為下一個指令的 `stdin`，形成一個處理流程。

- **範例**:
  ```bash
  # 顯示目前目錄下所有檔案，透過 grep 過濾出包含 "zip" 的行，再計算總行數
  tux@suse16:~> ls -l | grep "zip" | wc -l
  ```
  這個指令串接了三個程式：`ls` 的輸出 -> `grep` 的輸入 -> `grep` 的輸出 -> `wc` 的輸入。

#### 6-3-2-1. tee

在管線處理過程中，如果希望將中間步驟的輸出儲存到檔案中，同時繼續將輸出傳遞給下一個指令，可以使用 `tee` 指令。它就像一個 T 型水管，將數據流一分為二。

- **`tee` 範例**:

  ```bash
  # 將 ls -l 的結果同時顯示在螢幕上，並寫入 file.list 檔案，最後再計算總行數
  tux@suse16:~> ls -l | tee file.list | wc -l

  # 使用 -a 選項可以附加內容到檔案，而非覆蓋
  tux@suse16:~> ls -al | tee -a file.list | wc -l
  ```

### 6-3-3. 字串處理與參數擴展

BASH 提供強大的參數擴展 (Parameter Expansion) 功能，除了處理前後綴，還能優雅地處理未設定或為空的變數。

#### 移除前後綴

- **`#` 和 `##` (移除前綴)**:
  - `#`: 移除從頭開始最短的匹配。
  - `##`: 移除從頭開始最長的匹配。
- **`%` 和 `%%` (移除後綴)**:

  - `%`: 移除從結尾開始最短的匹配。
  - `%%`: 移除從結尾開始最長的匹配。

- **範例**:

  ```bash
  filepath="/home/tux/documents/report.pdf"

  # 取得檔名 (移除最長的前綴 */)
  filename=${filepath##*/}
  echo "Filename: $filename"  # Output: report.pdf

  # 取得副檔名 (移除最短的前綴 *.)
  extension=${filename#*.}
  echo "Extension: $extension" # Output: pdf

  # 取得檔名主體 (移除最短的後綴 .*)
  basename=${filename%.*}
  echo "Basename: $basename"  # Output: report
  ```

#### 處理未設定或為空的變數

在撰寫腳本時，經常需要為變數提供預設值，或檢查變數是否存在。

- **`${parameter:-word}`**: 如果 `parameter` 未設定或為空，則使用 `word` 作為回傳值，但 **不改變** `parameter` 變數本身。
- **`${parameter:=word}`**: 如果 `parameter` 未設定或為空，則將 `word` **賦值** 給 `parameter`，並使用 `word` 作為回傳值。
- **`${parameter:?word}`**: 如果 `parameter` 未設定或為空，則將 `word` 作為錯誤訊息輸出到 `stderr` 並中斷腳本。
- **`${parameter:+word}`**: 如果 `parameter` **已設定且不為空**，則使用 `word` 作為回傳值，否則回傳空字串。

- **範例**:

  ```bash
  #!/bin/bash
  # ${parameter:-word}
  unset my_var
  echo "Default value: ${my_var:-'default'}" # 輸出 Default value: default
  echo "Original value: ${my_var}"          # 輸出 Original value: (空)

  # ${parameter:=word}
  unset my_var
  echo "Assigned value: ${my_var:='assigned'}" # 輸出 Assigned value: assigned
  echo "Original value: ${my_var}"            # 輸出 Original value: assigned

  # ${parameter:?word}
  unset my_var
  # 下一行會導致腳本錯誤並退出，顯示錯誤訊息
  # echo "Check value: ${my_var:?'my_var is not set!'}"

  # ${parameter:+word}
  my_var="exists"
  echo "Use new value: ${my_var:+'new_value'}" # 輸出 Use new value: new_value
  ```

#### 練習

1.  執行 `find /etc -name "*.conf"`，並將結果儲存到 `conf_files.txt`，同時將可能出現的 "Permission denied" 錯誤訊息丟棄。
2.  使用管線與 `tee`，找出 `/etc/passwd` 檔案中所有使用 `/bin/bash` 的使用者，將結果顯示在螢幕上，並同時儲存到 `bash_users.txt` 檔案中。
3.  給定一個變數 `url="https://www.opensuse.org/index.html"`，請用字串處理功能分別取出 `https` (協定) 和 `index.html` (檔名)。
4.  寫一個腳本，它檢查一個名為 `BACKUP_DIR` 的環境變數。如果該變數未設定或為空，腳本應使用 `/tmp/backup` 作為預設值並印出最終要使用的目錄路徑。

---

## 6-4. 常用文本處理指令

### 6-4-1. `head`, `tail`, `cut`, `tr`

- **`head`**: 顯示檔案的開頭幾行 (預設 10 行)。
  - **顯示前 5 行**:
    ```bash
    tux@suse16:~> head -n 5 /etc/passwd
    ```
- **`tail`**: 顯示檔案的結尾幾行 (預設 10 行)。
  - **持續監控檔案更新 (`-f`)**:
    ```bash
    tux@suse16:~> tail -f /var/log/messages
    ```
- **`cut`**: 按欄位或字元切割文本。
  - **以 `:` 為分隔符，取出 `/etc/passwd` 的第 1 欄 (使用者名稱)**:
    ```bash
    tux@suse16:~> cut -d ':' -f 1 /etc/passwd
    ```
- **`tr`**: 轉換或刪除字元。
  - **將輸入的小寫字母轉為大寫**:
    ```bash
    tux@suse16:~> echo "hello world" | tr 'a-z' 'A-Z'
    HELLO WORLD
    ```

### 6-4-2. `grep`, `sed`, `awk` (文本三劍客)

- **`grep`**: 全域規則運算式印出 (Global Regular Expression Print)。用於搜尋包含指定模式的行。

  - **在檔案中搜尋字串 (忽略大小寫 `-i`)**:
    ```bash
    tux@suse16:~> grep -i "error" /var/log/syslog
    ```
  - **反向搜尋 (顯示不包含模式的行 `-v`)**:
    ```bash
    tux@suse16:~> grep -v "^#" /etc/services
    ```

- **`sed`**: 流編輯器 (Stream Editor)。用於對文本進行取代、刪除、新增等操作。

  - **取代每一行的第一個 "suse" 為 "SUSE"**:
    ```bash
    tux@suse16:~> sed 's/suse/SUSE/' somefile.txt
    ```
  - **全域取代 (g flag)**:
    ```bash
    tux@suse16:~> sed 's/suse/SUSE/g' somefile.txt
    ```

- **`awk`**: 一種強大的文本處理語言，擅長按欄位處理數據。
  - **顯示 `/etc/passwd` 的第一欄和第七欄 (使用者和 Shell)**:
    ```bash
    # -F ':' 指定分隔符
    tux@suse16:~> awk -F':' '{print "User: " $1 ", Shell: " $7}' /etc/passwd
    ```
  - **計算磁碟使用率總和**:
    ```bash
    tux@suse16:~> df -h | awk '/^\/dev/ {sum+=$5} END {print sum "%"}'
    ```

### 6-4-3. `xargs`

`xargs` 從標準輸入讀取資料，並將其作為參數傳遞給其他指令。它能解決管線無法直接傳遞參數的問題。

- **範例**: 找出所有 `.log` 檔案並刪除它們。

  - **錯誤作法**: `ls *.log | rm` (rm 不接受來自 stdin 的檔名)
  - **正確作法**:

    ```bash
    # xargs 會將 ls 的輸出作為 rm 的參數
    tux@suse16:~> ls *.log | xargs rm

    # 更安全可靠的作法是搭配 find
    tux@suse16:~> find . -name "*.log" -print0 | xargs -0 rm
    ```

    (`-print0` 和 `-0` 用於處理檔名中可能包含空格或特殊字元的情況)

#### 練習

1.  使用 `head` 和 `tail` 組合，印出 `/etc/services` 檔案的第 11 到 20 行。
2.  使用 `grep` 找出 `/etc/ssh/sshd_config` 中所有未被註解 (`#`) 的設定行。
3.  使用 `awk` 計算家目錄下所有檔案的總大小 (提示: `ls -l | awk '...'`)。
4.  在當前目錄下建立三個檔案 `a.tmp`, `b.tmp`, `c.tmp`，然後用 `find` 和 `xargs` 一次性刪除它們。

---

## 6-5. 其他實用功能

### 6-5-1. `compgen`

`compgen` 是 BASH 內建指令，可以根據指定的選項產生符合條件的補全列表，常用於腳本中。

- **顯示所有可用的指令**:
  ```bash
  tux@suse16:~> compgen -c
  ```
- **顯示所有別名**:
  ```bash
  tux@suse16:~> compgen -a
  ```
- **顯示所有變數**:
  ```bash
  tux@suse16:~> compgen -v
  ```

### 6-5-2. `complete`

`complete` 是 BASH 內建指令，用於定義 Tab 自動補全的行為。這是一個進階功能，可以極大提升自訂指令的易用性。

- **範例**: 讓一個名為 `mycmd` 的指令在按下 Tab 時，自動提示 `start`, `stop`, `restart`。

  ```bash
  # -W "..." 表示補全列表 (Wordlist)
  tux@suse16:~> complete -W "start stop restart" mycmd

  # 現在輸入 mycmd [TAB][TAB]，就會看到這三個選項
  tux@suse16:~> mycmd
  start   stop    restart
  ```

---

## 總結

本章從 BASH 的基本概念與設定檔出發，詳細介紹了變數、條件判斷、迴圈與函式等核心語法。也探討了 Shell 強大的 I/O 重新導向與管線機制，並學習了 `grep`, `sed`, `awk` 等一系列關鍵的文本處理工具。掌握 BASH 腳本編程，能有效率地與 Linux 系統互動，更能將日常的重複性工作自動化，是 Linux 使用者與系統管理員的必備技能。透過不斷練習，能組合這些簡單的工具，來解決複雜的問題。
