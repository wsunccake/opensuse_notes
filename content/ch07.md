# ch7. 虛擬化與容器化

隨著硬體效能的飛速發展，單一實體主機上僅執行單一作業系統與應用程式，往往造成嚴重的資源浪費。為了解決這個問題，虛擬化 (Virtualization) 與容器化 (Containerization) 技術應運而生。這兩種技術都旨在更有效率地利用運算資源，但在實作方式與應用場景上各有不同。本章將詳細介紹這兩種技術的核心概念，以及在 openSUSE 上的主流實作工具。

## 7-1. Virtualization / 虛擬化技術

虛擬化技術是指透過軟體或韌體層，在單一的實體硬體上，模擬出多個獨立且隔離的虛擬電腦 (Virtual Machine, VM)。每一個 VM 都擁有自己獨立的作業系統 (Guest OS)、虛擬化的硬體資源 (CPU、記憶體、磁碟、網路卡)，並且與其他 VM 和實體主機 (Host) 之間是完全隔離的。

管理這些 VM 的核心軟體稱為「**Hypervisor**」或「虛擬機器監視器 (Virtual Machine Monitor, VMM)」，主要分為兩種類型：

- **Type-1 (裸機型)**: Hypervisor 直接安裝在實體硬體之上，作業系統本身就是 Hypervisor 的一部分。這種架構效能較高，因為它直接控制硬體資源。常見範例有 `KVM`、`Xen`、`VMware ESXi`。
- **Type-2 (託管型)**: Hypervisor 作為一個應用程式，安裝在一個已經存在的作業系統 (Host OS) 之上。這種架構設定簡單，適合桌面應用，但效能相比 Type-1 會有一定的損耗。常見範例有 `VMware Workstation`、`Oracle VirtualBox`。

### 7-1-1. 主流虛擬化方案

- **`Xen`**: 一個成熟的開源 Type-1 Hypervisor，以其高效能和高安全性著稱，是許多大型雲端服務供應商 (如 AWS) 早期基礎架構的核心。
- **`VMware ESXi`**: VMware 推出的企業級 Type-1 Hypervisor，是其 `vSphere` 虛擬化平台的核心元件。它直接安裝在實體伺服器上，以無與倫比的效能、穩定性和豐富的生態系統，成為全球資料中心市場的絕對領導者。通常會透過 `vCenter Server` 進行集中化的高階管理。
- **`VMware Workstation / Fusion`**: 由 VMware 公司開發的商業 Type-2 Hypervisor。`Workstation` 適用於 Windows 和 Linux 平台，而 `Fusion` 則專為 macOS 設計。它們功能強大、穩定性高，是開發人員和 IT 專業人員在個人電腦上執行多個作業系統的首選工具之一。
- **`Oracle VirtualBox`**: 一款非常受歡迎的免費且開源的 Type-2 Hypervisor。它支援跨平台 (Windows, macOS, Linux)，因其設定簡單、易於使用和免費的特性，在開發人員、學生和個人使用者中有著廣泛的應用。
- **`KVM (Kernel-based Virtual Machine)`**: Linux 核心內建的虛擬化基礎設施。自 Linux 核心 2.6.20 版本之後，Linux 核心本身就是一個 Type-1 Hypervisor。KVM 負責處理最核心的 CPU 和記憶體虛擬化，它利用現代 CPU 的硬體輔助虛擬化技術 (Intel VT-x 或 AMD-V)，使 VM 能以接近原生的速度執行。

### 7-1-2. KVM - QEMU - Libvirt：Linux 虛擬化的黃金組合

在 Linux 環境中，KVM 並不單獨運作，而是與 QEMU 和 Libvirt 緊密結合，形成一個功能完整且強大的開源虛擬化平台。

- **`KVM` 的角色 - 大腦 (The Brain)**: 如前所述，KVM 是內建於 Linux 核心的模組。它負責最關鍵的 CPU 和記憶體資源調度，為虛擬機提供一個可以直接存取硬體資源的通道。它提供了一個名為 `/dev/kvm` 的裝置介面，讓使用者空間的應用程式可以藉此來建立和管理 VM。

- **`QEMU (Quick EMUlator)` 的角色 - 身體 (The Body)**: QEMU 是一個功能強大的通用機器模擬器與虛擬器。在 KVM 架構中，QEMU 負責模擬 VM 所需的各種週邊硬體，例如：主機板、BIOS/UEFI、硬碟控制器、光碟機、網路卡、顯示卡、USB 控制器等。當 VM 執行時，需要大量運算的 CPU 指令會由 KVM 直接在主機 CPU 上高速執行；而當 VM 需要存取被模擬的硬體裝置時 (例如讀寫磁碟)，QEMU 則會介入處理。簡單來說，**KVM 負責加速運算，QEMU 負責模擬硬體**。

- **`Libvirt` 的角色 - 遙控器 (The Remote Control)**: 直接使用 QEMU 的命令列參數來建立和管理 VM 是一件非常複雜且容易出錯的工作。Libvirt 是一個開源的 API、守護行程和管理工具，它提供了一套統一、穩定的介面，用來管理各種不同的 Hypervisor (不僅是 KVM/QEMU，還包括 Xen, VirtualBox 等)。開發者和系統管理員可以使用 `libvirt` 提供的工具 (如 `virsh` 命令列工具、`virt-manager` 圖形介面) 來輕鬆地操作 VM，而無需關心底層 Hypervisor 的複雜指令與細節。

#### 常用指令與設定

- **檢查硬體支援**:
  在安裝虛擬化軟體之前，必須確認 CPU 是否支援硬體虛擬化技術 (Intel VT-x 或 AMD-V)。

  - **`/proc/cpuinfo`**: 檢查 `/proc/cpuinfo` 檔案中是否包含 `vmx` (Intel) 或 `svm` (AMD) 。如果指令有輸出，表示 CPU 支援硬體虛擬化。

  ```bash
  tux@suse16:~> grep -E 'svm|vmx' /proc/cpuinfo
  ```

- **安裝套件**:
  openSUSE 提供了模式 (pattern) 來簡化 KVM 相關套件的安裝。

  - **`kvm_server`**: 安裝 KVM 伺服器所需的核心套件。
  - **`kvm`, `qemu`, `libvirt`**: 手動安裝 KVM、QEMU 和 Libvirt 核心元件。
  - **`virt-manager`**: 安裝 `virt-manager` 圖形化管理工具，它會自動將 `qemu` 和 `libvirt` 等依賴套件一併安裝。

  ```bash
  tux@suse16:~> sudo zypper in -t pattern kvm_server
  tux@suse16:~> sudo zypper in kvm qemu libvirt
  tux@suse16:~> sudo zypper in virt-manager
  ```

- **管理 `libvirt` 服務**:
  `libvirtd` 是 `libvirt` 的主要守護行程，必須在背景執行才能管理 VM。

  ```bash
  tux@suse16:~> sudo systemctl status libvirtd.service
  tux@suse16:~> sudo systemctl enable libvirtd.service
  tux@suse16:~> sudo systemctl start libvirtd.service
  ```

#### `libvirt` 相關服務說明

- **`libvirtd.service`**: `libvirt` 的核心管理守護行程。它負責監聽來自 `virsh`、`virt-manager` 等客戶端的 API 請求，並執行建立、刪除、啟動、停止 VM 等所有管理操作。
- **`libvirt-guests.service`**: 一個系統服務腳本。當主機開機時，它會自動啟動被設定為「自動啟動」的虛擬機；當主機關機時，它會依序正常關閉或儲存執行中的虛擬機，以防止資料遺失。
- **`libvirt-dbus.service`**: 透過 D-Bus 系統訊息匯流排提供 `libvirt` 的 API。這允許非 `root` 權限的桌面應用程式能夠以安全的方式查詢虛擬機的狀態或進行有限的操作。
- **`libvirtd.socket`, `libvirtd-ro.socket`, `libvirtd-admin.socket`**: 這些是 `systemd` 的 Socket-Activation (通訊端啟用) 單元。它們讓 `systemd` 預先監聽對應的通訊埠。當有客戶端連線請求時，`systemd` 才會自動啟動 `libvirtd` 守護行程來處理請求。這種方式更有效率，因為在沒有管理需求時，`libvirtd` 可以不用常駐在記憶體中。
  - `libvirtd.socket`: 用於一般讀寫的管理連線。
  - `libvirtd-ro.socket`: 用於唯讀的監控連線。
  - `libvirtd-admin.socket`: 用於本機最高權限的管理連線。

#### 使用 `virsh` 和 `virt-manager`

- **`virsh` (Virtualization Shell)**: 一個功能強大的命令列工具，用於管理 `libvirt` 所支援的虛擬機。

  - **`sudo virsh list --all`**: 列出所有已定義的虛擬機，包含正在執行和已關機的。
  - **`sudo virsh start <vm-name>`**: 啟動指定的虛擬機。例如：`sudo virsh start opensuse-vm`。
  - **`sudo virsh destroy <vm-name>`**: 強制關閉虛擬機，相當於直接「拔掉電源」，可能導致資料遺失。
  - **`sudo virsh console <vm-name>`**: 連接到虛擬機的序列控制台 (Serial Console)。這需要在虛擬機內部啟用 `ttyS0` 裝置，是一個在沒有圖形介面或網路時進行管理的有效方法。
    - 在 Guest OS 內部執行: `sudo systemctl enable serial-getty@ttyS0.service --now`

- **`virt-manager` (Virtual Machine Manager)**: 一個圖形化的桌面應用程式，提供了建立、設定、監控和操作虛擬機的完整功能，非常適合初學者和桌面使用者。

  - **`virt-manager`**: 在終端機中執行此指令即可啟動圖形介面。

### 練習

1.  **硬體檢查**: 執行 `grep -E 'svm|vmx' /proc/cpuinfo` 指令，確認 CPU 是否支援硬體虛擬化。
2.  **安裝與啟用**: 在 openSUSE 上使用 `sudo zypper in virt-manager` 安裝圖形化管理工具，並使用 `systemctl` 啟用並啟動 `libvirtd` 服務。
3.  **建立虛擬機**: 開啟 `virt-manager`，嘗試使用 openSUSE 的 ISO 映像檔建立一個新的虛擬機。
4.  **指令列管理**: 虛擬機建立後，使用 `virsh list --all` 查看其狀態，並嘗試使用 `virsh start` 和 `virsh shutdown` (正常關機) 來管理它。

---

## 7-2. 容器化技術 (Containerization)

容器化是另一種輕量級的虛擬化技術，通常被稱為「作業系統層級的虛擬化」。與模擬一整台硬體電腦的 VM 不同，**所有容器共享主機 (Host) 的作業系統核心**。容器技術是將應用程式本身，以及其執行所需的所有相依套件、函式庫和設定檔，全部打包在一起，形成一個獨立、隔離但輕量的執行環境，即「容器」。

**與虛擬機的比較**:

| 特性         | 虛擬機 (VM)                          | 容器 (Container)                      |
| :----------- | :----------------------------------- | :------------------------------------ |
| **隔離層級** | **硬體層級** (Hypervisor 模擬硬體)   | **作業系統層級** (共享核心，隔離行程) |
| **資源消耗** | **高** (每個 VM 都有獨立的 Guest OS) | **低** (共享 Host 核心，無額外 OS)    |
| **啟動速度** | **分鐘級** (需啟動完整 OS)           | **秒級或毫秒級** (僅啟動應用程式行程) |
| **大小**     | **GB 級** (包含完整 OS)              | **MB 級** (僅包含應用程式與函式庫)    |
| **執行環境** | 獨立、封閉、安全                     | 隔離，但共享核心                      |

### 7-2-1. 主流容器化方案

- **`Docker`**: Docker 是將容器技術推向主流市場的關鍵推手。它提供了一套非常完善的工具鏈，讓開發者可以輕易地 **建立 (build)**、**分享 (ship)** 和 **執行 (run)** 容器。Docker 採用 Client-Server 架構，其核心是一個稱為 `dockerd` 的守護行程在背景執行，負責所有容器的建立、網路、儲存等管理工作。

- **`Podman`**: Podman (Pod Manager) 是一個開源的容器管理工具，其最大特色是 **無守護行程 (Daemonless)** 架構。它被設計為 Docker 的直接替代品，其命令列工具與 Docker 幾乎完全相容 (可以 `alias docker=podman`)。因為每次執行指令時才啟動對應程序，而不需要一個擁有 `root` 權限的常駐背景服務，Podman 在安全性和與 `systemd` 等現代 Linux 系統服務的整合上被認為更具優勢。在 openSUSE 和 other RHEL 系列的發行版中，Podman 已逐漸成為預設的容器管理工具。

### 7-2-2. Docker 操作入門

#### `docker` vs `docker-stable`

在安裝時，可能會遇到不同的套件名稱，但都是 Moby-project。

- **`docker`**: 此套件是較新版本 docker ce (**Community Edition**) 。
- \*\*`docker-stable`: 此套件是較穩定版本 (LTS)

對於學習和大多數應用場景，使用發行版提供的 `docker` 套件即可。

#### 常用指令與設定

- **安裝 Docker**:
  從 openSUSE 官方庫安裝 Docker。

  ```bash
  tux@suse16:~> sudo zypper in docker
  ```

- **管理 Docker 服務**:
  Docker 的 `dockerd` 守護行程需要作為系統服務執行。

  ```bash
  tux@suse16:~> sudo systemctl status docker.service
  tux@suse16:~> sudo systemctl enable docker.service
  tux@suse16:~> sudo systemctl start docker.service
  ```

- **設定使用者權限**:
  預設情況下，只有 `root` 使用者有權限與 Docker 守護行程通訊。為了讓一般使用者也能直接執行 `docker` 指令，需要將該使用者加入 `docker` 群組。**此變更需要重新登入後才會生效**。

  ```bash
  tux@suse16:~> sudo usermod -aG docker <user>
  ```

- **基本指令**:

  - **`測試`**: 下載並執行 `hello-world` 映像檔，用於驗證 Docker 是否安裝成功。

  ```bash
  tux@suse16:~> docker run --rm hello-world
  ```

  - **`images`**: 列出本機已下載的所有映像檔 (Image)。
  - **`pull`**: 從 Docker Hub (預設的映像檔倉庫) 下載指定的映像檔。
  - **`run`**: 使用指定的映像檔來建立並啟動一個新的容器。
    `--rm` 參數表示容器執行結束後自動刪除。
  - **`ps`**: 列出目前正在執行的容器。
    `-a`: 列出所有容器，包含已停止的。
  - **`start`**: 啟動一個已停止的容器。
  - **`stop`**: 正常停止一個正在執行的容器。
  - **`logs`**: 查看指定容器的日誌輸出。
  - **`rm`**: 刪除一個已停止的容器。
  - **`rmi`**: 刪除一個映像檔。

  ```bash
  tux@suse16:~> docker images
  tux@suse16:~> docker pull <image-name>
  tux@suse16:~> docker run [--rm] <image-name>
  tux@suse16:~> docker ps [-a]
  tux@suse16:~> docker start <container-id>
  tux@suse16:~> docker stop <container-id>
  tux@suse16:~> docker logs <container-id>
  tux@suse16:~> docker rm <container-id>
  tux@suse16:~> docker rmi <image-id>
  ```

### 練習

1.  **安裝與設定**: 安裝 `docker` 套件，啟用並啟動 `docker` 服務，並將目前的使用者加入 `docker` 群組 (記得重新登入)。
2.  **驗證安裝**: 執行 `docker run --rm hello-world`，確認是否能看到歡迎訊息。
3.  **拉取映像檔**: 執行 `docker pull alpine`，從 Docker Hub 下載輕量級的 `alpine` Linux 映像檔。
4.  **執行互動式容器**: 執行 `docker run -it alpine sh`。這會啟動一個 `alpine` 容器，並讓您進入容器的 shell 環境 (`-it` 代表互動模式)。在容器內，嘗試執行 `ls`、`cat /etc/os-release` 等指令，感受容器的隔離環境。完成後輸入 `exit` 退出容器。
5.  **管理容器**: 執行 `docker ps -a` 查看剛剛已退出的容器，並使用 `docker rm` 將其刪除。最後使用 `docker rmi alpine` 刪除 `alpine` 映像檔。

## 7-3. 總結

本章介紹了現代 IT 架構中兩種至關重要的資源利用技術：虛擬化與容器化。
- **虛擬化 (Virtualization)** 以 **VMware** 和 **KVM** 為代表，透過模擬完整的硬體，提供了最強的隔離性與相容性，適合執行需要不同作業系統或對環境有嚴格要求的應用程式。在 Linux 世界，**KVM + QEMU + Libvirt** 的組合提供了一個強大且完全開源的解決方案。
- **容器化 (Containerization)** 以 **Docker** 和 **Podman** 為代表，透過共享主機核心，實現了極高的資源效率和啟動速度。它改變了現代軟體的開發、打包與部署流程 (CI/CD)，特別適合微服務架構。
理解這兩種技術的差異與適用場景，是現代系統管理員與開發人員的必備技能。虛擬化提供的是「電腦的虛擬化」，而容器化提供的是「應用程式的虛擬化」。在許多複雜的系統中，這兩種技術甚至會同時被使用，例如在虛擬機中執行容器，以結合兩者的優點。
